#!/usr/bin/env python3
'''
Author:       boettchc
Class:        cs372-400-f2019
Assignment:   Program 2 
Date:         November 24, 2019

Some of this code was taken from Section 2.7 of Kurose and Ross. Most of it was 
reused from Program 1.
'''
from socket import *
import argparse
import signal
import sys
from pathlib import Path

#regex for checking to see if the client wants to quit
QUIT=r'^.*\\quit'
DEBUG=False
DIR_MAX=5120
FILE_MAX=16777216
BUFF_SZ=4096


'''
pre:  a SIGINT has been received by the program
in:   a signal object and a frame object
out:  n/a
post: application exits with status 0
'''
def trap_sigint(sig, frame):
  print("SIGINT received. Exiting.", flush=True)
  sys.exit(0)


'''
pre:  n/a
in:   n/a
out:  a Namespace object, as created by the ArgumentParser
post: global var DEBUG set to true if arguments included '-d'
note: the '-d' argument is for internal use only and is not shown to the user in usage
'''
def parse_args():
  global DEBUG
  parser = argparse.ArgumentParser(description='A simple file transfer client.')
  parser.add_argument('-d', action='store_true', help=argparse.SUPPRESS) 
  parser.add_argument('server', type=str, nargs=1, help='the server that the client should connect to') 
  parser.add_argument('cmdport', type=int, nargs=1, help='the command port that the client should connect to') 
  parser.add_argument('-g', type=str, nargs=2, dest='get_args', help='get a remote file')
  #the command for the server (either -l or -g)',
  #parser.add_argument('filename', type=str, nargs=1, help='the file that the client requests')
  parser.add_argument('-l', type=str, nargs=1, dest='list_dport', help='list the contents of the remote directory')
  #parser.add_argument('dataport', type=int, nargs=1, help='the dataport that the client should\
  #    receive on') 
  args = parser.parse_args() 
  if args.d:
    DEBUG=True
  return args


'''
pre:  n/a 
in:   a port supplied by the user which the server will listen on
out:  n/a
post: server listening on port parameter
'''
def connect_to_server(addr, port):
  sock1 = socket(AF_INET, SOCK_STREAM)
  #reuse the socket if client terminates abruptly
  sock1.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1) 
  #STEP 4 
  sock1.connect((addr, port))
  return sock1


def get_rdir(cmdsock, dport, srvname):
  lcmd_args = "-l " + dport 
  datasock = socket(AF_INET, SOCK_STREAM) 
  datasock.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1) 
  datasock.bind(('', int(dport)))
  datasock.listen(1)
  #STEP 6 
  cmdsock.sendall(lcmd_args.encode())
  if DEBUG: print("After call to sendall in get_rdir", file=sys.stderr, flush=True)
  cxSckt, addr = datasock.accept()
  with cxSckt:
    dirlist = cxSckt.recv(DIR_MAX)
    #decode the dirlist received 
    if dirlist != b'':
      print('Receiving directory structure from {0} on port {1}'.format(srvname, dport))
      print(dirlist.decode('utf-8'), flush=True)
    else:
      print("No directory listing received\n", flush=True)
    cxSckt.shutdown(SHUT_RDWR)
    cxSckt.close()
  #close the command/control socket
  cmdsock.close()     


def save_file(fname, buff):
  #check if file already exists in cwd
  filepath = Path("./"+fname)
  if filepath.exists():
    prompt = "File {0} exists. Overwrite? (y/n) ".format(fname)
    answ = ''
    while answ not in ('y','Y','n','N'):
      answ = input(prompt)
    if answ in ('n','N'):
      print("Not overwriting file. Exiting.")
      return False

  f = open(fname, "w", encoding="utf-8")
  f.write(buff.decode('utf-8'))
  f.close()
  return True


def get_rfile(cmdsock, arg_list, srvname, cmdport):
  getcmd_args = "-g " + arg_list[0] + " " + arg_list[1]
  datasock = socket(AF_INET, SOCK_STREAM) 
  datasock.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1) 
  datasock.bind(('', int(arg_list[1])))
  datasock.listen(1)
  #STEP 6 
  cmdsock.sendall(getcmd_args.encode())
  #get cmd response 
  cmdresp = cmdsock.recv(BUFF_SZ)
  if cmdresp != b'':
    print('{0}:{1} says "{2}"'.format(srvname, cmdport, cmdresp.decode('utf-8')))
    cmdsock.shutdown(SHUT_RDWR)
    cmdsock.close()
    exit(1)

  cxSckt, addr = datasock.accept()
  with cxSckt:
    #https://stackoverflow.com/a/17668009/148680 
    buff = bytearray()
    while(True):
      recvd_bytes = cxSckt.recv(BUFF_SZ)
      if not recvd_bytes:
        break
      else:
        buff.extend(recvd_bytes) 

    #pass the filename and the bytes object to save_file 
    if save_file(arg_list[0], buff):
      print('Receiving {0} from {1} on port {2}'.format(arg_list[0],
          srvname, arg_list[1]), flush=True)
      print("File transfer complete.\n", flush=True)  
    else:
      print("No directory listing received\n", flush=True)
    cxSckt.shutdown(SHUT_RDWR)
    cxSckt.close()
  #close the command/control socket
  cmdsock.close()     


def main():
  #register the signal handler for SIGINT
  signal.signal(signal.SIGINT, trap_sigint)

  #parse cmdline; STEP 3  
  args = parse_args()

  cmdsock = connect_to_server(args.server[0], args.cmdport[0])
  if DEBUG: print('cmdsock: {0}'.format(cmdsock), file=sys.stderr) 
  
  if args.list_dport:
    get_rdir(cmdsock, args.list_dport[0], args.server[0]) 
  elif args.get_args:
    get_rfile(cmdsock, args.get_args, args.server[0], args.cmdport[0])


if __name__ == "__main__":
      main()

